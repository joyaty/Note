# 纹理（Texture）

我们已经知道我们可以为每个顶点添加颜色属性来增加对象的细节，来创建一些有趣的图像。但是，如果要更真实一点，我们就需要大量的顶点，这样需要指定大量的颜色。这想来就是一件工作量巨大的事，因为每个模型都有大量的顶点，而每个顶点都有颜色属性。

艺术家和程序们更喜欢使用**纹理（Texture）**。纹理是一张2D图片（甚至有1D或是3D的纹理），用来描述对象的细节。想象一下纹理是一张有着砖块图像的墙纸贴在3D的房子上，使得你的房子看起来具有石头砖块的外观。因为我们可以在图片上添加大量的细节，因此我们会觉得对象非常精细，而我们不需要添加额外的顶点。

*P.S. 不仅仅是图片，纹理也可以用来保存需要发送到Shader的大量任意数据。*

为了将纹理映射到三角形上，我们必须告诉每个三角形的顶点关联纹理的哪一部分。因此每个顶点需要有**纹理坐标（Texture Coordinate）**来指定采样纹理的哪一部分。然后使用片段插值处理其他片段。

纹理坐标在X轴和Y轴的范围都是[0,1]（2D纹理）。通过纹理坐标获取纹理的颜色被称为**采样（Sampling）**。纹理坐标的(0, 0)点表示纹理图片的左下角，(1,1)点表示纹理图片的右上角。下面的图片解释了如何映射纹理坐标到三角形上。

![](C:\WorkSpace\Note\Learn OpenGL\images\5.TexCoords.png)

我们只想传递三个顶点的纹理坐标到片段着色器中，接下来会通过的插值将纹理坐标传递到每个片段着色器上。

纹理坐标会是这样的：

```c++
float texCoords[] = {
    0.0f, 0.0f,	// 左下 
    1.0f, 0.0f, // 右下
    0.5f, 1.0f,	// 顶部中点
}
```

纹理采样的解释很宽松，有很多种插值方式可以进行纹理采样插值。因此我们需要告诉OpenGL如何采样纹理。

------

### 纹理环绕方式（Texture Wrapping）

纹理坐标的范围是(0, 0)到(1, 1)，如果我们指定的坐标超出了这个范围，会发生什么？OpenGL的默认方式是重复采样这个纹理图片（我们基本上忽略浮点纹理坐标的整数部分），OpenGL还提供了其他方式：

- GL_REPEAT：纹理的默认方式，重复纹理图片。
- GL_MIRROR_REPEAT：同样重复纹理，但是每次都镜像图片。
- GL_CLAMP_TO_EDGE：将坐标限制在0到1，超出范围的坐标变限制在边缘上，因此边缘会被重复，产生边缘被拉伸的效果。
- GL_CLAMP_TO_BORDER：超出范围的坐标允许用户指定一个颜色。

当使用超出范围的纹理坐标是，每种选项都会在视觉上产生不同效果。下面图片直观展示了各个选项的不同视觉效果：

![5.TextureWrapping](C:\WorkSpace\Note\Learn OpenGL\images\5.TextureWrapping.png)

我们可以通过**glTexParameter***一系列函数在每个坐标轴上（通常为s，t轴，如果是3D纹理则还有r轴，分别类比xyz）设置前面提到的各类选项。

```c++
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);
```

第一个参数是纹理目标类型，我们使用的是2D纹理，因此指定为GL_TEXTURE_2D。第二个参数是指定我们在哪个选项以及哪个轴上设置选项，我们在S轴和T轴上都设置。第三个指定了使用哪种纹理环绕方式。

如果选择指定了**GL_CLAMP_TO_BORDER**，而我们还需要指定一个边框颜色。我们可以使用glTexParamer带有fv后缀的函数来设置，我们指定选项为**GL_CLAMP_TO_BORDER**，然后传递一个float类型的数组来指定边框颜色。

```c++
float borderColor = {1.0f, 1.0f, 0.0f, 1.0f};
glTexParameterfv(GL_TEXTURE_2D, GL_CLAMP_TO_BORDER, borderColor);
```

------

### 纹理过滤（Texture Filtering）

纹理坐标不依赖于分辨率，可以时任意浮点数值，因此OpenGL需要指定如何将**纹理像素（Texture Pixel，也被称为Texel，纹素）**映射到相应的纹理坐标。尤其是当你有非常大的物体，而纹理分辨率很低的情况下就特别重要。同样的，OpenGL也有一些选项用于配置Texture Filtering。这里，我们目前只讨论最重要的两个选项：**GL_NEAREST**和**GL_LINEAR**。

*P.S. Texture Pixel也叫Texel。想象打开一张.jpg格式图片，不断放大会发现它是有无数像素点组成的，这个点就是纹理像素。注意不要和纹理坐标搞混，纹理坐标是设置给模型顶点的数组，OpenGL以这个纹理坐标数据去查找纹理图像上的像素，然后采样提取纹理像素的颜色。*

**GL_NEAREST(也被称为邻近(点)过滤，Nearest neighbor or point filtering)**是OpenGL默认的纹理过滤方法。当设置为GL_NEAREST时，OpenGL会选择中心最靠近纹理坐标的纹理像素。下图十字代表的纹理坐标附近有4个像素，因为左上角像素中心做接近纹理坐标，因此左上角的像素颜色会被采样。

![](C:\WorkSpace\Note\Learn OpenGL\images\5.FilterNearest.png)

**GL_LINEAR(也被称为线性过滤，(Bi)Linear filtering)**从纹理坐标附近的纹素计算一个插值，生成一个接近这些纹素的色值。纹理中心距离像素坐标越近，采样颜色的比重越大，下图解释了线性过滤：

![](C:\WorkSpace\Note\Learn OpenGL\images\5.FilterLinear.png)

两种方式在视觉上到底有什么不同？下图展示了两种方式作用在一个巨大的对象和低分辨率的纹理上的效果（纹理被放大了，每个像素都可以看清楚）。

![5.TextureFiltering](C:\WorkSpace\Note\Learn OpenGL\images\5.TextureFiltering.png)

**GL_NEAREST**模式产生更加锯齿化的输出，我们可以比较清楚的看到一个个组成纹理的图片，而**GL_LINEAR**模式产生更平滑的输出，几乎看不出独立的像素。**GL_LINEAR**产出更加真实的输出，但是一些开发者更喜欢使用8-bit分隔，而选择使用**GL_NEAREST**。