# 纹理（Texture）

我们已经知道我们可以为每个顶点添加颜色属性来增加对象的细节，来创建一些有趣的图像。但是，如果要更真实一点，我们就需要大量的顶点，这样需要指定大量的颜色。这想来就是一件工作量巨大的事，因为每个模型都有大量的顶点，而每个顶点都有颜色属性。

艺术家和程序们更喜欢使用**纹理（Texture）**。纹理是一张2D图片（甚至有1D或是3D的纹理），用来描述对象的细节。想象一下纹理是一张有着砖块图像的墙纸贴在3D的房子上，使得你的房子看起来具有石头砖块的外观。因为我们可以在图片上添加大量的细节，因此我们会觉得对象非常精细，而我们不需要添加额外的顶点。

*P.S. 不仅仅是图片，纹理也可以用来保存需要发送到Shader的大量任意数据。*

为了将纹理映射到三角形上，我们必须告诉每个三角形的顶点关联纹理的哪一部分。因此每个顶点需要有**纹理坐标（Texture Coordinate）**来指定采样纹理的哪一部分。然后使用片段插值处理其他片段。

纹理坐标在X轴和Y轴的范围都是[0,1]（2D纹理）。通过纹理坐标获取纹理的颜色被称为**采样（Sampling）**。纹理坐标的(0, 0)点表示纹理图片的左下角，(1,1)点表示纹理图片的右上角。下面的图片解释了如何映射纹理坐标到三角形上。

![](images/5.TexCoords.png)

我们只想传递三个顶点的纹理坐标到片段着色器中，接下来会通过的插值将纹理坐标传递到每个片段着色器上。

纹理坐标会是这样的：

```c++
float texCoords[] = {
    0.0f, 0.0f,	// 左下 
    1.0f, 0.0f, // 右下
    0.5f, 1.0f,	// 顶部中点
}
```

纹理采样的解释很宽松，有很多种插值方式可以进行纹理采样插值。因此我们需要告诉OpenGL如何采样纹理。

------

### 纹理环绕方式（Texture Wrapping）

纹理坐标的范围是(0, 0)到(1, 1)，如果我们指定的坐标超出了这个范围，会发生什么？OpenGL的默认方式是重复采样这个纹理图片（我们基本上忽略浮点纹理坐标的整数部分），OpenGL还提供了其他方式：

- GL_REPEAT：纹理的默认方式，重复纹理图片。
- GL_MIRROR_REPEAT：同样重复纹理，但是每次都镜像图片。
- GL_CLAMP_TO_EDGE：将坐标限制在0到1，超出范围的坐标变限制在边缘上，因此边缘会被重复，产生边缘被拉伸的效果。
- GL_CLAMP_TO_BORDER：超出范围的坐标允许用户指定一个颜色。

当使用超出范围的纹理坐标是，每种选项都会在视觉上产生不同效果。下面图片直观展示了各个选项的不同视觉效果：

![5.TextureWrapping](images/5.TextureWrapping.png)

我们可以通过**glTexParameter***一系列函数在每个坐标轴上（通常为s，t轴，如果是3D纹理则还有r轴，分别类比xyz）设置前面提到的各类选项。

```c++
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);
```

第一个参数是纹理目标类型，我们使用的是2D纹理，因此指定为GL_TEXTURE_2D。第二个参数是指定我们在哪个选项以及哪个轴上设置选项，我们在S轴和T轴上都设置。第三个指定了使用哪种纹理环绕方式。

如果选择指定了**GL_CLAMP_TO_BORDER**，而我们还需要指定一个边框颜色。我们可以使用glTexParamer带有fv后缀的函数来设置，我们指定选项为**GL_CLAMP_TO_BORDER**，然后传递一个float类型的数组来指定边框颜色。

```c++
float borderColor = {1.0f, 1.0f, 0.0f, 1.0f};
glTexParameterfv(GL_TEXTURE_2D, GL_CLAMP_TO_BORDER, borderColor);
```

------

### 纹理过滤（Texture Filtering）

纹理坐标不依赖于分辨率，可以是任意浮点数值，因此OpenGL需要指定如何将**纹理像素（Texture Pixel，也被称为Texel，纹素）**映射到相应的纹理坐标。尤其是当你有非常大的物体，而纹理分辨率很低的情况下就特别重要。同样的，OpenGL也有一些选项用于配置**Texture Filtering**。这里，我们目前只讨论最重要的两个选项：**GL_NEAREST**和**GL_LINEAR**。

*P.S. Texture Pixel也叫Texel。想象打开一张.jpg格式图片，不断放大会发现它是有无数像素点组成的，这个点就是纹理像素。注意不要和纹理坐标搞混，纹理坐标是设置给模型顶点的数组，OpenGL以这个纹理坐标数据去查找纹理图像上的像素，然后采样提取纹理像素的颜色。*

**GL_NEAREST(也被称为邻近(点)过滤，Nearest neighbor or point filtering)**是OpenGL默认的纹理过滤方法。当设置为GL_NEAREST时，OpenGL会选择中心最靠近纹理坐标的纹理像素。下图十字代表的纹理坐标附近有4个像素，因为左上角像素中心做接近纹理坐标，因此左上角的像素颜色会被采样。

![](images/5.FilterNearest.png)

**GL_LINEAR(也被称为线性过滤，(Bi)Linear filtering)**从纹理坐标附近的纹素计算一个插值，生成一个接近这些纹素的色值。纹理中心距离像素坐标越近，采样颜色的比重越大，下图解释了线性过滤：

![](images/5.FilterLinear.png)

两种方式在视觉上到底有什么不同？下图展示了两种方式作用在一个巨大的对象和低分辨率的纹理上的效果（纹理被放大了，每个像素都可以看清楚）。

![5.TextureFiltering](images/5.TextureFiltering.png)

**GL_NEAREST**模式产生更加锯齿化的输出，我们可以比较清楚的看到一个个组成纹理的像素，而**GL_LINEAR**模式产生更平滑的输出，几乎看不出独立的像素。**GL_LINEAR**产出更加真实的输出，但是一些开发者更喜欢像素风格（8-bit look），而选择使用**GL_NEAREST**。

当进行放大缩小操作时，可以设置纹理过滤的选项。比如缩小时，可以选择**GL_NEAREST**模式，而放大时，可以选择**GL_LINEAR**模式。我们同样可以通过**glTexPrameter***函数指定纹理过滤的方式。

```c++
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
```

------

### Mipmaps（多级渐远纹理）

想象有一个大房间，房间内有成千上万的物件，每个物件都存在纹理贴图。有一些远离观察者的物件和靠近观察者的物件有着相同的高分辨率纹理贴图。因为那些物件可能足够远，在视窗中仅仅产生几个片段（Fragment），OpenGL为这些片段计算纹理颜色时就会有些困难，因为这个纹理坐标可能映射了高分辨率纹理上的一大片区域，OpenGL不得不从这大片纹理中中计算出最终的纹理颜色。在小物件上使用高分辨率纹理也会浪费显存。

OpenGL中使用**Mipmaps**这个概念来解决这个问题。Mipmaps中包含一组纹理图片，每个纹理图片是上个纹理图片的二分之一。Mipmaps背后的理念很简单：当物件远离观察者一定距离后，使用更小分辨率的纹理来适配当前距离的物件，而因为距离足够远，低分辨率的纹理对用户来说没有明显的区别。这样，OpenGL就可以容易的采样正确的纹理颜色，同时降低了显存占用。

![5.Mipmaps](images/5.Mipmaps.png)

为每个纹理收到创建Mipmaps是非常麻烦的。幸运的是，OpenGL提供了glGenerateMipmaps函数供我们使用，它能能够在我们创建纹理后，方便的自动创建该纹理的Mipmaps。

在渲染过程中切换Mipmaps级别时，OpenGL可能会产生一些伪像，比如在两个Mipmaps级别间可见的尖锐边缘。Mipmaps层级间的过滤（Filtering）也可以向普通纹理过滤那样，使用**NEAREST**或者**LINEAR**来指定Mipmaps级别切换时的过滤方式。我们可以使用以下的Mipmaps过滤标识来代替普通的纹理过滤标识。

- GL_NEAREST_MIPMAP_NEAREST：使用邻近Mipmap来匹配纹理，使用邻近过滤采样。
- GL_LINEAR_MIPMAP_NEAREST：使用邻近Mipmap来匹配纹理，使用线性插值方式采样
- GL_NEAREST_MIPMAP_LINEAR：在最匹配的两个Mipmaps级别来进行线性插值来匹配，使用邻近过滤采样。
- GL_LINEAR_MIPMAP_LINEAR：在最匹配的两个Mipmaps级别来进行线性插值来匹配，使用线性插值方式采样。

和纹理过滤一样，我们可以使用**glTexParameteri**函数来设置Mipmaps的过滤方式。

```c++
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
```

一个常见的错误是将Mipmaps过滤选项设置在纹理放大过滤上，这是没有任何效果的，因为Mipmaps主要用来适配缩小的纹理。纹理放大不会使用Mipmaps，并且如果错误的设置了Mipmaps选项，将会返回一个错误码：GL_INVALID_ENUM。

------

### 加载和创建纹理

使用纹理的第一步是需要将纹理图片加载进来。我们可以使用一些开源的图片加载库（image-loading library），比如stb_image.h。

stb_image.h是非常流行的单头文件图片加载库。它可以加载大部分流行的图片文件格式，并且很容易的整合到自己的项目中。

```c++
#define STB_IMAGE_IMPLEMENTION
#include "stb_image.h"
```

