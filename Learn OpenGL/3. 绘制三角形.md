# 绘制三角形

OpenGL中，所有的物件都是三维空间中的，但是我们的屏幕或者窗口是二维的，因此OpenGL中很大一部分工作是将三维坐标装换为屏幕二维坐标。这部分在被称为**OpenGL渲染管线（Graphics pipeline of OpenGL）**的流程中处理。OpenGL渲染管线主要可以划分为两部分，第一部分将三维空间坐标转化为二维屏幕坐标，第二部分将二维屏幕坐标转为为显示设备上的像素（colored pixels）。这部分，我们将探讨OpenGL渲染管线，以及如何通过它渲染出一个三角形。

------

### OpenGL渲染管线

OpenGL渲染管线将接受一组三维空间坐标，并最终转化为二维屏幕上的像素点。可以将渲染管线划分为几个部分，每一部分将上一部分的输出作为输入处理。这些部分都是高度专业化的，并且各部分很容易被并行执行。现代显卡的设计也因为渲染管线的天然并行执行特性，而设计了成千上万的小处理核心可以快速的在渲染管线中处理数据。这些处理核心为渲染管线的各个部分运行着在GPU上执行的小程序，这些小程序被称之为**着色器（Shader）**。

渲染管线中某些步骤的Shader可以被我们所控制，我们可以编写自己的Shader来替换默认的Shader，这样我们就可以更加细粒度的控制OpenGL渲染管线中的特定步骤，而且因为Shader运行在GPU上，因此它可以节省CPU的效能。Shader可以使用**OpenGL Shading Language（GLSL）**来编写。

下图，可以看下渲染管线各个步骤的抽象图示。注意，蓝色的部分是可被我们控制的。

![3.GraphicsPipelineOfOpenGL](images/3.GraphicsPipelineOfOpenGL.png)

如上图所示，渲染管线包含的许多步骤，通过这些步骤一步步将我们输入的顶点数据转为像素点。下面我们将简要的介绍渲染管线的各个部分，这样可以对渲染管线的运行有一个初步的了解。

首先，我们将一组可以组成三角形的三维坐标以数组的形式作为输入传递给渲染管线，这些数据被称为**顶点数据（Vertex Data）**，它是一些顶点的集合。一个顶点是一个三维坐标的数据集合，这些数据被称为**顶点属性（Vertex Attribute）**，可以包含任何我们想要的数据。简单起见，先让每个顶点属性包含一个三维坐标和一些顶点颜色数据。

*为了让OpenGL知道我们传递的输入数据要渲染什么，比如要使用这些数据渲染一个三角形？渲染一个点？或者是渲染一条线？我们需要指定如何让OpenGL来组织这些输入数据，这些渲染类别被称为**图元（Primitives）**。OpenGL提供了一些图元类别，比如**GL_POINTS**，**GL_TRIANGLES**以及**GL_LINE_STRIP**，在调用任何渲染指令时，我们都需要指定图元类型。*

 渲染管线的第一个步骤是**顶点着色器（Vertex Shader）**。它将一个顶点作为输入，主要作用是将顶点的3D坐标转化为另一种坐标，同时对顶点属性做一些基础的处理。

下一个步骤是**图元装配（Primitive Assembly）**，它将所有顶点着色器输出的顶点作为输入（如果将图元指定为GL_POINT，则是一个顶点），将这些顶点装配为指定的图元形状。

图元装配阶段输出的数据将被传递到渲染管线的下一阶段中，被称为**几何着色器（Geometry Shader）**。几何着色器输入可以组成指定图元的一些列顶点，能够通过新增新的顶点来生成新的（或是其他的）图元形状。上图中，图元转配生成一个三角形被几何着色器分成两个新的三角形。

几何着色器处理结束后，结果被传递到渲染管线的下一阶段，被称为**光栅化（Rasteriaztion Stage）**。在此步骤中，几何着色器输出的最终的图元被映射到屏幕对应的像素上，生成一系列**片段（Fragment）**供下一阶段，被称为**片段着色器（Fragment Shader）**，使用。在片段着色器运行之前，**裁剪（Clipping）**被执行，所有屏幕视图范围外的片段被丢弃，以减少片段着色器处理的数据量，提升性能。

*OpenGL中的一个片段是OpenGL渲染一个像素需要的全部数据。*

**片段着色器（Fragment Shader）**的主要目的就是计算一个像素的最终颜色，这里也通常是OpenGL中各种高级效果产生的地方。通常，片段着色器中还包含3D场景中的一些数据（比如光照，阴影，光的颜色等等），以便片段着色器能够计算出最终的像素色值。

当所有的像素颜色被计算确定后，最后会被传递到渲染管线的最终阶段，被称为**Alpha测试和混合（Alpha Test And Blending）**阶段。此阶段中，将检查各个片段的深度值和模板值，并且通过这些数据确定一个片段是在其他物体的前面还是后面，以及是否应该被丢弃，同时还检查片段的Alpha值（该值定义了片段的透明度），以确定是否需要混合其他物体的颜色。因此，即使片段着色器中计算了像素的颜色，最后渲染在屏幕上的颜色也可能与片段着色器不同。

如你所见，OpenGL的渲染管线是非常复杂的，且包含了许多可配置的阶段。实际上，在大多数场合中，我们只需要处理**顶点着色器（Vertex Shader）**和**片段着色器（Fragment Shader）**的阶段，几何着色器是可选的且通常使用默认的Shader。且这里还没有介绍**曲面细分阶段（Tessellation Stage）**和**变换反馈阶段（Transform Feedback Loop）**。

在现代OpenGL中，至少要先定义一个顶点着色器和一个片段着色器（GPU中没有默认的顶点着色器和片段着色器）。因此对于初学者而言，学习OpenGL是很困难的，因为在渲染出第一个三角形之前，就需要了解大量的渲染管线知识。本节结束，当你绘制出第一个三角形后，就会对图形编程有一个大概的认识。

------

### 顶点输入

为了绘制一些东西，我们必须要提供一些顶点数据到OpenGL中。OpenGL是一个3D渲染库，因此我们必须提供3D坐标（x，y，z坐标），而且，OpenGL不会简单的将所有的顶点都传递到渲染管线中，OpenGL只处理xyz3个坐标轴上位于[-1,1]范围的顶点，位于此范围的被称为**标准设备坐标系（Normalized Device Coordinates）**范围，这个范围对应到屏幕上的各个像素。

因为我们准备绘制一个三角形，因此我们需要指定3个位于标准设备坐标系的3D坐标，如下所示，在一个float数组中定义个各个坐标位置。

```c++
float vertices[] = {
    -0.5f, -0.5f, 0.0f,
     0.5f, -0.5f, 0.0f,
     0.0f,  0.5f, 0.0f
};
```

因为OpenGL工作在3D空间，而目前只绘制2D三角形，因此给定的3个坐标，z轴都是0。这样所有顶点的**深度（Depth）**就是一样的，看起来就是2D的。

P.S. **标准设备坐标系（Normalized Device Coordinates，简称NDC）**，一旦顶点坐标在顶点着色器中处理结束后，输出的顶点应该都在是标准设备坐标系中（xyz轴的坐标范围在[-1，1]区间内）。任何在此范围外的顶点都会被丢弃或者裁剪，在屏幕空间是不可见的。